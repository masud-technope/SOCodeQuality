You've just recreated a very expensive LinearLayout.
Except a `LinearLayout` doesn't have all the inherent niceties of a `ListView` -- it doesn't have dividers, header/footer views, a list selector which matches the phone's UI theme colors, etc.  Honestly, there's no reason why you can't scroll the inner container until it's reached the end and then have it stop intercepting touch events so that the outer container scrolls.  Every desktop browser does this when you're using your scroll wheel.  Android itself can handle nested scrolling if you're navigating via the trackball, so why not via touch?
For solution by DoughW there is a bug, however i fixed it, see [my post](http://nex-otaku-en.blogspot.com/2010/12/android-put-listview-in-scrollview.html).
`listItem.measure(0,0)` will throw a NPE if listItem is a ViewGroup instance. I added the following before `listItem.measure`: `if (listItem instanceof ViewGroup) listItem.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));`.
Fix for ListViews with padding other than 0.
Unfortunately this method is a bit flawed when the `ListView` can contain items of variable height.  The call to `getMeasuredHeight()` only returns the targeted minimum height as opposed to the actual height.  I tried using `getHeight()` instead, but this returns 0.  Does anyone have any insight on how to approach this?
